"""
Estimates psychophysical performance limit using Signal Detection Theory as described in Heinz et al. (2001)
"""

import numpy as np
import thorns as th

def calc_psychophysical_performance_limit(model, stim_fct, delta, cfs, model_pars=None):
    """
    Estimates psychophysical performance limit using Signal Detection Theory
    @params:
        model       - Required  : auditory nerve model that estimates instantaneous firing rate
        stim_fct    - Required  : stimulus generating function having one parameter "delta", e.g. stim_fct = lambda delta : (1+delta)*np.sin(2*np.pi*np.linspace(0,1,16e3))
        delta       - Required  : delta of the stimulus paramter to derive approximated partial derivative, e.g. 0.0001
        cfs         - Required  : center frequencies of nerve fibres, e.g. np.linspace(125, 16e3, 10)
        model_pars  - Optional  : parameters to be fed through to model

    based on Heinz et al. 2001 "Evaluating Auditory Performance Limits: I. One-Parameter Discrimination Using a Computational Model for the Auditory Nerve"

    "roughly two-thirds of the 30,000 total AN fibers in human are represented by the model."
    "model only represents high-spontaneous-rate, low-threshold fibers, which make up 61% of the population in cat"
    "Thus, predictions in this study are based on a population of 12,200 total AN fibers,
    where each of the 60 model responses represent roughly 200 independent AN fibers."
   
    A sampling frequency of 500 kHz was used for all predictions, except for three highfrequency
    conditions for which higher sampling rates were chosen to avoid subharmonic
    distortion generated by the saturating nonlinearity for specific relations between stimulus
    and sampling frequency. In general, this sampling artifact was most prominent for high
    levels and high frequencies, and thus for high frequencies the predictions were limited to
    low to medium levels.   
    """

    # TODO: test that model outputs instantaneous firing rate and not spike events 

    if model_pars is None:
        model_pars = {}

    fs = model_pars.setdefault('fs', 100e3)
    model_pars.setdefault('anf_types', ('hsr'))

    ifr1_pd = th.util.map(
        _run_model,
        space = { 'cf': cfs },
        kwargs = { 'model': model, 'model_pars': model_pars, 'sound': stim_fct(0) },
        backend = None # 'multiprocessing',
    )
    ifr1_pd.columns = ['ifr']
    ifr2_pd = th.util.map(
        _run_model,
        space = { 'cf': cfs },
        kwargs = { 'model': model, 'model_pars': model_pars, 'sound': stim_fct(delta) },
        backend = None # 'multiprocessing',
    )
    ifr2_pd.columns = ['ifr']

    # until I fully understand pandas DataFrame MultiIndex access I need to do this
    stimlen = ifr1_pd['ifr'].values[0].shape[0]
    ifr1 = np.zeros((len(cfs), stimlen))
    ifr2 = np.zeros((len(cfs), stimlen))
    for i in np.arange(irf1.shape[0]):
        ifr1[i,:] = ifr1_pd['ifr'].values[i].unstack()
        ifr2[i,:] = ifr2_pd['ifr'].values[i].unstack()

    # due to the "small-x" approximation a minimal ISR of 7 spikes per second was used
    ifr1[ifr1<7.0] = 7.0
    ifr2[ifr2<7.0] = 7.0

    pd_AI = (ifr2-ifr1)/delta                                    # equation (4.1)
    JND_AI = np.sum(np.sum( (1/fs) * (pd_AI**2) / ifr1 ))**-0.5  # equation (3.1)
    in1_RP = (1/fs) * np.sum(ifr1)
    in2_RP = (1/fs) * np.sum(ifr2)
    pd_RP  = (in2_RP - in1_RP)/delta;                           # equation (4.1)
    JND_RP_human = np.sum( (pd_RP**2)/in1_RP )**-0.5                                # equation (3.1)

def _run_model(model, model_pars, cf, sound):
    ifr = model(sound=sound, cf=cf, **model_pars)
    return ifr
